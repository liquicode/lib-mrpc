!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.lib_mrpc=n():e.lib_mrpc=n()}("undefined"!=typeof self?self:this,(function(){return function(e){var n={};function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(i,r,function(n){return e[n]}.bind(null,r));return i},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=2)}([function(e,n,t){"use strict";n.ServiceProvider=function(e,n){return{ServiceName:e,Options:n,IsPortOpen:!1,EndpointManager:{Endpoints:{},EndpointExists:function(e){return void 0!==this.Endpoints[e]},AddEndpoint:function(e,n){let t={EndpointName:e,Handler:n};return this.Endpoints[e]=t,t},RemoveEndpoint:function(e){this.EndpointExists(e)&&delete this.Endpoints[e]},EachEndpoint:function(e){Object.keys(this.Endpoints).forEach(n=>e(this.Endpoints[n],n))},HandleEndpoint:async function(e,n){if(this.EndpointExists(e))return await this.Endpoints[e].Handler(n)}},MessageManager:{Messages:[],AddMessage:function(e){this.Messages.push(e)},NextMessage:function(){if(0===this.Messages.length)return null;let e=this.Messages[0];return this.Messages=this.Messages.slice(1),e},PeekMessage:function(){return 0===this.Messages.length?null:this.Messages[0]},ClearMessages:function(){this.Messages=[]}},Sleep:async function(e){return new Promise(n=>setTimeout(n,e))},WaitWhile:async function(e){return new Promise(async(n,t)=>{for(;e();)await this.Sleep(1);n(!0)})},WaitUntil:async function(e){return new Promise(async(n,t)=>{for(;!e();)await this.Sleep(1);n(!0)})},ApplyDefaultOptions:function(e){e=e||{};let n=JSON.parse(JSON.stringify(e));return function e(n,t){let i=Object.keys(t);for(let r=0;r<i.length;r++){let o=i[r];"object"==typeof t[o]&&null!==t[o]?(void 0===n[o]&&(n[o]={}),e(n[o],t[o])):void 0===n[o]&&(n[o]=t[o])}}(n,this.DefaultOptions()),n},DefaultOptions:function(){throw new Error("DefaultOptions is not implemented in ServiceProvider.")},OpenPort:async function(){throw new Error("OpenPort is not implemented in ServiceProvider.")},ClosePort:async function(){throw new Error("ClosePort is not implemented in ServiceProvider.")},AddEndpoint:async function(e,n){throw new Error("AddEndpoint is not implemented in ServiceProvider.")},CallEndpoint:async function(e,n,t=null){throw new Error("CallEndpoint is not implemented in ServiceProvider.")}}}},function(e,n){e.exports=require("uniqid")},function(e,n,t){"use strict";const i=t(3);n.ImmediateServiceProvider=i.ImmediateServiceProvider;const r=t(4);n.DeferredServiceProvider=r.DeferredServiceProvider;const o=t(5);n.WorkerThreadServiceProvider=o.WorkerThreadServiceProvider;const s=t(7);n.StompServiceProvider=s.StompServiceProvider;const a=t(9);n.TortoiseServiceProvider=a.TortoiseServiceProvider;const c=t(11);n.AmqpLibServiceProvider=c.AmqpLibServiceProvider;const l=t(13);n.RedisServiceProvider=l.RedisServiceProvider,n.ServiceClient={Services:{},ConnectService:function(e){let n=e.ServiceName;if(void 0!==this.Services[n])throw new Error(`The service [${n}] already exists.`);this.Services[n]=e},DisconnectService:function(e){void 0!==this.Services[e]&&delete this.Services[e]},CallEndpoint:function(e,n,t,i){if(void 0===this.Services[e])throw new Error(`The service [${e}] does not exist.`);this.Services[e].CallEndpoint(n,t,i)}}},function(e,n,t){"use strict";const i=t(0);n.ImmediateServiceProvider=function(e,n){let t=i.ServiceProvider(e,n);return t.DefaultOptions=()=>({}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(i,r)=>{if(t.EndpointManager.EndpointExists(e))return void r(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));t.EndpointManager.AddEndpoint(e,n);i(!0)}),t.CallEndpoint=async function(e,n,i=null){return new Promise(async(r,o)=>{if(t.EndpointManager.EndpointExists(e))try{let o=await t.EndpointManager.HandleEndpoint(e,n);return i&&i(null,o),void r(o)}catch(e){return i&&i(e,null),void o(e)}else o(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`))})},t}},function(e,n,t){"use strict";const i=t(0);n.DeferredServiceProvider=function(e,n){let t=i.ServiceProvider(e,n);return t.process_next_message=async()=>{if(!t.IsPortOpen)return;let e=t.MessageManager.NextMessage();if(e)try{let n=await t.EndpointManager.HandleEndpoint(e.EndpointName,e.CommandParameters);e.ReplyCallback&&e.ReplyCallback(null,n)}catch(n){e.ReplyCallback&&e.ReplyCallback(n,null)}setImmediate(t.process_next_message)},t.DefaultOptions=()=>({}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,t.process_next_message(),e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!1;let i=t.MessageManager.Messages.length;i>0&&console.warn(`DeferredServiceProvider Warning: The port was closed but there are still [${i}] messages left in the queue.`),e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(i,r)=>{if(t.EndpointManager.EndpointExists(e))return void r(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));t.EndpointManager.AddEndpoint(e,n);i(!0)}),t.CallEndpoint=async(e,n,i=null)=>new Promise(async(r,o)=>{if(!t.EndpointManager.EndpointExists(e))return void o(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`));let s={EndpointName:e,CommandParameters:n,ReplyCallback:(e,n)=>{i&&i(e,n),e?o(e):r(n)}};t.MessageManager.AddMessage(s)}),t}},function(e,n,t){"use strict";const i=t(0),{Worker:r,isMainThread:o,parentPort:s,workerData:a}=t(6);n.WorkerThreadServiceProvider=function(e,n){let t=i.ServiceProvider(e,n);return t.DefaultOptions=()=>({max_threads:10}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(i,r)=>{if(t.EndpointManager.EndpointExists(e))return void r(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));t.EndpointManager.AddEndpoint(e,n);i(!0)}),t.CallEndpoint=async(e,n,i=null)=>new Promise(async(o,s)=>{if(t.EndpointManager.EndpointExists(e))try{let a=t.EndpointManager.Endpoints[e].Handler.toString(),c=null;c=`\n\t\t\t\t\t\tconst { parentPort, workerData } = require( 'worker_threads' );\n\t\t\t\t\t\tlet result =\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t${a}\n\t\t\t\t\t\t)( workerData );\n\t\t\t\t\t\tparentPort.postMessage( result );\n\t\t\t\t\t\t`;let l=new r(c,{eval:!0,workerData:n});l.once("message",e=>{i&&i(null,e),o(e)}),l.once("error",e=>{i&&i(e,null),s(e)})}catch(e){i&&i(e,null),s(e)}else s(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`))}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("worker_threads")},function(e,n,t){"use strict";const i=t(8),r=t(1);n.StompServiceProvider=function(e,n){return{ServiceName:e,Options:n,Endpoints:{},QueueClient:null,Messages:[],IsPortOpen:!1,OpenPort:async function(){this.QueueClient=await i.connect(this.Options),this.IsPortOpen=!0},ClosePort:async function(){this.IsPortOpen=!1;let e=this.Messages.length;e>0&&console.warn(`The port was closed but there are still [${e}] messages left in the queue.`)},AddEndpoint:async function(e,n){if(void 0!==this.Endpoints[e])throw new Error(`The endpoint [${e}] already exists within [${this.ServiceName}].`);let t=this.QueueClient.subscribe({destination:`/queue/${this.ServiceName}/${e}`,ack:"client-individual"},(function(e,t){if(e)throw new Error("Queue subscription Error: "+e.message);t.readString("utf-8",(function(e,i){if(e)throw new Error("Queue message read Error: "+e.message);console.log("received message: "+i);try{n(i),t.ack()}catch(e){t.nack(e)}}))}));this.Endpoints[e]={EndpointName:e,Handler:n,Subscription:t}},DestroyEndpoint:async function(e){void 0!==this.Endpoints[e]&&(this.Endpoints[e].Subscription.unsubscribe(),delete this.Endpoints[e])},CallEndpoint:async function(e,n,t){if(void 0===this.Endpoints[e])throw new Error(`The endpoint [${e}] does not exist within [${this.ServiceName}].`);let i=r(),o=(this.QueueClient.subscribe({destination:`/queue/${this.ServiceName}/${e}/${i}`,ack:"client-individual"},(function(e,n){if(e)throw new Error("Queue reply subscription Error: "+e.message);n.readString("utf-8",(function(e,i){if(e)throw new Error("Queue reply message read Error: "+e.message);console.log("received reply message: "+i),t(null,i),n.ack()}))})),{EndpointName:e,CommandParameters:n,CommandCallback:i});const s={destination:`/queue/${this.ServiceName}/${e}`,"content-type":"text/plain"},a=this.QueueClient.send(s);a.write(JSON.stringify(o)),a.end()}}}},function(e,n){e.exports=require("stompit")},function(e,n,t){"use strict";const i=t(0),r=t(10),o=t(1);n.TortoiseServiceProvider=function(e,n){let t=i.ServiceProvider(e,n);return t.QueueClient=null,t.DefaultOptions=()=>({server:"amqp://guest:guest@localhost:5672",connect_options:{connectRetries:30,connectRetryInterval:1e3},command_queue_options:{exclusive:!1,durable:!1,autoDelete:!0},reply_queue_options:{exclusive:!1,durable:!1,autoDelete:!0}}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.QueueClient=new r(t.Options.server,t.Options.connect_options),t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{let i=Object.keys(t.EndpointManager.Endpoints);for(let e=0;e<i.length;e++){let n=t.EndpointManager.Endpoints[i[e]];await n.Channel.close()}t.QueueClient&&(await t.QueueClient.destroy(),t.QueueClient=null),t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(i,r)=>{if(t.EndpointManager.EndpointExists(e))return void r(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));let o=await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}`,t.Options.command_queue_options).prefetch(1).subscribe((async function(n,i,r){try{let r=JSON.parse(n),o=await t.EndpointManager.HandleEndpoint(r.EndpointName,r.CommandParameters);r.ReplyID&&await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}/${r.ReplyID}`,t.Options.reply_queue_options).publish(JSON.stringify(o)),i()}catch(e){console.error(Error.message,e),r(!1)}}));t.EndpointManager.AddEndpoint(e,n).Channel=o,i(!0)}),t.CallEndpoint=async(e,n,i)=>new Promise(async(r,s)=>{if(!t.EndpointManager.EndpointExists(e))return void s(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`));let a=o(),c=await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}/${a}`,t.Options.reply_queue_options).prefetch(1).subscribe((async function(e,n,t){try{let t=JSON.parse(e);i&&i(null,t),n(),r(t)}catch(e){t(!1),i&&i(e,null),s(e)}finally{await c.close()}})),l={EndpointName:e,CommandParameters:n,ReplyID:a};await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}`,t.Options.command_queue_options).publish(l)}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("tortoise")},function(e,n,t){"use strict";const i=t(0),r=t(12),o=t(1);n.AmqpLibServiceProvider=function(e,n){let t=i.ServiceProvider(e,n);return t.QueueClient=null,t.DefaultOptions=()=>({server:"amqp://guest:guest@localhost:5672",connect_options:{connectRetries:30,connectRetryInterval:1e3},command_queue_options:{exclusive:!1,durable:!1,autoDelete:!0},reply_queue_options:{exclusive:!1,durable:!1,autoDelete:!0}}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.QueueClient=await r.connect(t.Options.server,t.Options.connect_options),t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{let i=Object.keys(t.EndpointManager.Endpoints);for(let e=0;e<i.length;e++){let n=t.EndpointManager.Endpoints[i[e]];await n.Channel.close()}t.QueueClient&&(await t.QueueClient.close(),t.QueueClient=null),t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(i,r)=>{let o=null;if(t.EndpointManager.EndpointExists(e))return void r(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));let s=`${t.ServiceName}/${e}`,a=await t.QueueClient.createChannel();o=await a.prefetch(1),o=await a.assertQueue(s,t.Options.command_queue_options),o=await a.consume(s,(async function(e){if(e)try{let n=e.content.toString(),i=JSON.parse(n),r=await t.EndpointManager.HandleEndpoint(i.EndpointName,i.CommandParameters);if(i.ReplyID){let e=s+"/"+i.ReplyID,n=await t.QueueClient.createChannel();o=await n.assertQueue(e,t.Options.reply_queue_options),o=n.sendToQueue(e,Buffer.from(JSON.stringify(r)),{contentType:"text/plain",persistent:!1})}a.ack(e)}catch(n){console.error(Error.message,n),a.nack(e,!1,!1)}})),t.EndpointManager.AddEndpoint(e,n).Channel=a,i(!0)}),t.CallEndpoint=async(e,n,i=null)=>new Promise(async(r,s)=>{if(!t.EndpointManager.EndpointExists(e))throw new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`);let a=o(),c=`${t.ServiceName}/${e}/${a}`,l=await t.QueueClient.createChannel();await l.assertQueue(c,t.Options.reply_queue_options),await l.consume(c,(function(e){if(e)try{let n=e.content.toString(),t=JSON.parse(n);i&&i(null,t),r(t)}catch(e){i&&i(e,null),s(e)}finally{l.close()}}),{noAck:!0});let u={EndpointName:e,CommandParameters:n,ReplyID:a},d=`${t.ServiceName}/${e}`,p=await t.QueueClient.createChannel();await p.assertQueue(d,t.Options.command_queue_options),await p.sendToQueue(d,Buffer.from(JSON.stringify(u)),{contentType:"text/plain",persistent:!1}),await p.close()}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("amqplib")},function(e,n,t){"use strict";const i=t(0),r=t(14),o=t(1);n.RedisServiceProvider=function(e,n){let t=i.ServiceProvider(e,n);return t.DefaultOptions=()=>({host:null,port:null,path:null,url:"redis://localhost:6379"}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{let i=Object.keys(t.EndpointManager.Endpoints);for(let e=0;e<i.length;e++){let n=t.EndpointManager.Endpoints[i[e]];n.Channel.unsubscribe(),n.Channel.quit()}t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(i,o)=>{if(t.EndpointManager.EndpointExists(e))return void o(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));let s=`${t.ServiceName}/${e}`,a=r.createClient(t.Options);a.on("message",(async function(n,i){try{let n=JSON.parse(i),o=await t.EndpointManager.HandleEndpoint(n.EndpointName,n.CommandParameters);if(n.ReplyID){let i=`${t.ServiceName}/${e}/${n.ReplyID}`,s=r.createClient(t.Options);s.publish(i,JSON.stringify(o)),s.quit()}}catch(e){console.error(Error.message,e)}})),a.subscribe(s),t.EndpointManager.AddEndpoint(e,n).Channel=a,i(!0)}),t.CallEndpoint=async(e,n,i)=>new Promise(async(s,a)=>{if(!t.EndpointManager.EndpointExists(e))return void a(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`));let c=o(),l=`${t.ServiceName}/${e}/${c}`,u=r.createClient(t.Options);u.on("message",(function(e,n){try{let e=JSON.parse(n);i&&i(null,e),s(e)}catch(e){nack(!1),i&&i(e,null),a(e)}finally{u.unsubscribe(),u.quit()}})),u.subscribe(l);let d={EndpointName:e,CommandParameters:n,ReplyID:c},p=`${t.ServiceName}/${e}`,f=r.createClient(t.Options);f.publish(p,JSON.stringify(d)),f.quit()}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("redis")}])}));