!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.lib_mrpc=n():e.lib_mrpc=n()}("undefined"!=typeof self?self:this,(function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=1)}([function(e,n,t){"use strict";const r=t(3);n.ServiceProvider=function(e,n){return{ServiceName:e,Options:n,IsPortOpen:!1,EndpointManager:{Endpoints:{},EndpointExists:function(e){return void 0!==this.Endpoints[e]},AddEndpoint:function(e,n){let t={EndpointName:e,Handler:n};return this.Endpoints[e]=t,t},RemoveEndpoint:function(e){this.EndpointExists(e)&&delete this.Endpoints[e]},EachEndpoint:function(e){Object.keys(this.Endpoints).forEach(n=>e(this.Endpoints[n],n))},HandleEndpoint:async function(e,n){if(this.EndpointExists(e))return await this.Endpoints[e].Handler(n)}},MessageManager:{Messages:[],AddMessage:function(e){this.Messages.push(e)},NextMessage:function(){if(0===this.Messages.length)return null;let e=this.Messages[0];return this.Messages=this.Messages.slice(1),e},PeekMessage:function(){return 0===this.Messages.length?null:this.Messages[0]},ClearMessages:function(){this.Messages=[]}},UniqueID:function(e=12){let n="abcdefghijklmnopqrstuvwxyz1234567890",t="";for(let i=0;i<e;i++)t+=0===i?"abcdefghijklmnopqrstuvwxyz"[r.randomInt(0,"abcdefghijklmnopqrstuvwxyz".length-1)]:n[r.randomInt(0,n.length-1)];return t},ApplyDefaultOptions:function(e){e=e||{};let n=JSON.parse(JSON.stringify(e));return function e(n,t){let r=Object.keys(t);for(let i=0;i<r.length;i++){let o=r[i];"object"==typeof t[o]&&null!==t[o]?(void 0===n[o]&&(n[o]={}),e(n[o],t[o])):void 0===n[o]&&(n[o]=t[o])}}(n,this.DefaultOptions()),n},Sleep:async function(e){return new Promise(n=>setTimeout(n,e))},WaitWhile:async function(e){return new Promise(async(n,t)=>{for(;e();)await this.Sleep(1);n(!0)})},WaitUntil:async function(e){return new Promise(async(n,t)=>{for(;!e();)await this.Sleep(1);n(!0)})},DefaultOptions:function(){throw new Error("DefaultOptions is not implemented in ServiceProvider.")},OpenPort:async function(){throw new Error("OpenPort is not implemented in ServiceProvider.")},ClosePort:async function(){throw new Error("ClosePort is not implemented in ServiceProvider.")},AddEndpoint:async function(e,n){throw new Error("AddEndpoint is not implemented in ServiceProvider.")},CallEndpoint:async function(e,n,t=null){throw new Error("CallEndpoint is not implemented in ServiceProvider.")}}}},function(e,n,t){"use strict";n.ImmediateServiceProvider=(e,n)=>t(2).ImmediateServiceProvider(e,n),n.DeferredServiceProvider=(e,n)=>t(4).DeferredServiceProvider(e,n),n.WorkerThreadServiceProvider=(e,n)=>t(5).WorkerThreadServiceProvider(e,n),n.FSWatchServiceProvider=(e,n)=>t(7).FSWatchServiceProvider(e,n),n.AmqpLibServiceProvider=(e,n)=>t(11).AmqpLibServiceProvider(e,n),n.TortoiseServiceProvider=(e,n)=>t(13).TortoiseServiceProvider(e,n),n.RedisServiceProvider=(e,n)=>t(15).RedisServiceProvider(e,n),n.ServiceClient=()=>t(17).ServiceClient()},function(e,n,t){"use strict";const r=t(0);n.ImmediateServiceProvider=function(e,n){let t=r.ServiceProvider(e,n);return t.DefaultOptions=()=>({}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(r,i)=>{if(t.EndpointManager.EndpointExists(e))return void i(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));t.EndpointManager.AddEndpoint(e,n);r(!0)}),t.CallEndpoint=async function(e,n,r=null){return new Promise(async(i,o)=>{if(t.EndpointManager.EndpointExists(e))try{let o=await t.EndpointManager.HandleEndpoint(e,n);return r&&r(null,o),void i(o)}catch(e){return r&&r(e,null),void o(e)}else o(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`))})},t}},function(e,n){e.exports=require("crypto")},function(e,n,t){"use strict";const r=t(0);n.DeferredServiceProvider=function(e,n){let t=r.ServiceProvider(e,n);return t.process_next_message=async()=>{if(!t.IsPortOpen)return;let e=t.MessageManager.NextMessage();if(e)try{let n=await t.EndpointManager.HandleEndpoint(e.EndpointName,e.CommandParameters);e.ReplyCallback&&e.ReplyCallback(null,n)}catch(n){e.ReplyCallback&&e.ReplyCallback(n,null)}setImmediate(t.process_next_message)},t.DefaultOptions=()=>({}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,t.process_next_message(),e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!1;let r=t.MessageManager.Messages.length;r>0&&console.warn(`DeferredServiceProvider Warning: The port was closed but there are still [${r}] messages left in the queue.`),e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(r,i)=>{if(t.EndpointManager.EndpointExists(e))return void i(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));t.EndpointManager.AddEndpoint(e,n);r(!0)}),t.CallEndpoint=async(e,n,r=null)=>new Promise(async(i,o)=>{if(!t.EndpointManager.EndpointExists(e))return void o(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`));let s={EndpointName:e,CommandParameters:n,ReplyCallback:(e,n)=>{r&&r(e,n),e?o(e):i(n)}};t.MessageManager.AddMessage(s)}),t}},function(e,n,t){"use strict";const r=t(0),{Worker:i,isMainThread:o,parentPort:s,workerData:a}=t(6);n.WorkerThreadServiceProvider=function(e,n){let t=r.ServiceProvider(e,n);return t.DefaultOptions=()=>({max_threads:10}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(r,i)=>{if(t.EndpointManager.EndpointExists(e))return void i(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));t.EndpointManager.AddEndpoint(e,n);r(!0)}),t.CallEndpoint=async(e,n,r=null)=>new Promise(async(o,s)=>{if(t.EndpointManager.EndpointExists(e))try{let a=t.EndpointManager.Endpoints[e].Handler.toString(),l=null;l=`\n\t\t\t\t\t\tconst { parentPort, workerData } = require( 'worker_threads' );\n\t\t\t\t\t\tlet result =\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t${a}\n\t\t\t\t\t\t)( workerData );\n\t\t\t\t\t\tparentPort.postMessage( result );\n\t\t\t\t\t\t`;let c=new i(l,{eval:!0,workerData:n});c.once("message",e=>{r&&r(null,e),o(e)}),c.once("error",e=>{r&&r(e,null),s(e)})}catch(e){r&&r(e,null),s(e)}else s(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`))}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("worker_threads")},function(e,n,t){"use strict";const r=t(0),i=t(8),o=t(9),s=t(10);n.FSWatchServiceProvider=function(e,n){let t=r.ServiceProvider(e,n);return t.DefaultOptions=()=>({path:i.tmpdir()}),t.OpenPort=async()=>new Promise(async(e,n)=>{let r=s.resolve(t.Options.path);r=s.join(r,t.ServiceName),o.existsSync(r)||o.mkdirSync(r,{recursive:!0}),t.FSWatcher=o.watch(r,{persistent:!0,recursive:!1,encoding:"utf8"},async(e,n)=>{if(n&&n.endsWith(".cmd")&&"rename"===e){if(n=s.join(r,n),!o.existsSync(n))return;try{let e=o.readFileSync(n),i=JSON.parse(e),a={ReplyID:i.ReplyID,EndpointResult:null,EndpointError:null};try{a.EndpointResult=await t.EndpointManager.HandleEndpoint(i.EndpointName,i.CommandParameters)}catch(e){a.EndpointError=e.message}if(a.ReplyID){let e=s.join(r,a.ReplyID+".reply");o.writeFileSync(e,JSON.stringify(a))}}catch(e){console.error(Error.message,e)}finally{o.unlinkSync(n)}}}),t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{t.FSWatcher.close(),t.FSWatcher=null;let r=s.resolve(t.Options.path);r=s.join(r,t.ServiceName),o.existsSync(r)&&o.rmdirSync(r,{recursive:!0,maxRetries:10,retryDelay:100}),t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(r,i)=>{if(t.EndpointManager.EndpointExists(e))return void i(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));t.EndpointManager.AddEndpoint(e,n);r(!0)}),t.CallEndpoint=async(e,n,r)=>new Promise(async(i,a)=>{if(!t.EndpointManager.EndpointExists(e))return void a(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`));let l=s.resolve(t.Options.path);l=s.join(l,t.ServiceName),o.existsSync(l)||o.mkdirSync(l,{recursive:!0});let c=t.UniqueID(),p=c+".reply",u=o.watch(l,{persistent:!0,recursive:!1,encoding:"utf8"},async(e,n)=>{if(n&&n===p&&"rename"===e){if(n=s.join(l,n),!o.existsSync(n))return;try{let e=o.readFileSync(n),t=JSON.parse(e);if(t.EndpointError){let e=new Error(t.EndpointError);r&&r(e,null),a(e)}else r&&r(null,t.EndpointResult),i(t.EndpointResult)}catch(e){r&&r(e,null),a(e)}finally{u.close(),o.unlinkSync(n)}}}),d={EndpointName:e,CommandParameters:n,ReplyID:c},E=t.UniqueID(),y=s.join(l,E+".cmd");o.writeFileSync(y,JSON.stringify(d))}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("os")},function(e,n){e.exports=require("fs")},function(e,n){e.exports=require("path")},function(e,n,t){"use strict";const r=t(0);var i=null;try{i=t(12)}catch(e){throw console.error("The npm library [amqplib] was not found."),console.error("To install [amqplib] please use: npm install --save amqplib"),e}n.AmqpLibServiceProvider=function(e,n){let t=r.ServiceProvider(e,n);return t.QueueClient=null,t.DefaultOptions=()=>({server:"amqp://guest:guest@localhost:5672",connect_options:{connectRetries:30,connectRetryInterval:1e3},command_queue_options:{exclusive:!1,durable:!1,autoDelete:!0},reply_queue_options:{exclusive:!1,durable:!1,autoDelete:!0}}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.QueueClient=await i.connect(t.Options.server,t.Options.connect_options),t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{let r=Object.keys(t.EndpointManager.Endpoints);for(let e=0;e<r.length;e++){let n=t.EndpointManager.Endpoints[r[e]];await n.Channel.close()}t.QueueClient&&(await t.QueueClient.close(),t.QueueClient=null),t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(r,i)=>{let o=null;if(t.EndpointManager.EndpointExists(e))return void i(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));let s=`${t.ServiceName}/${e}`,a=await t.QueueClient.createChannel();o=await a.prefetch(1),o=await a.assertQueue(s,t.Options.command_queue_options),o=await a.consume(s,(async function(e){if(e)try{let n=e.content.toString(),r=JSON.parse(n),i={ReplyID:r.ReplyID,EndpointResult:null,EndpointError:null};try{i.EndpointResult=await t.EndpointManager.HandleEndpoint(r.EndpointName,r.CommandParameters)}catch(e){i.EndpointError=e.message}if(i.ReplyID){let e=s+"/"+i.ReplyID,n=await t.QueueClient.createChannel();o=await n.assertQueue(e,t.Options.reply_queue_options),o=n.sendToQueue(e,Buffer.from(JSON.stringify(i)),{contentType:"text/plain",persistent:!1})}a.ack(e)}catch(n){console.error(Error.message,n),a.nack(e,!1,!1)}})),t.EndpointManager.AddEndpoint(e,n).Channel=a,r(!0)}),t.CallEndpoint=async(e,n,r=null)=>new Promise(async(i,o)=>{let s=null;if(!t.EndpointManager.EndpointExists(e))throw new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`);let a=t.UniqueID(),l=`${t.ServiceName}/${e}/${a}`,c=await t.QueueClient.createChannel();s=await c.assertQueue(l,t.Options.reply_queue_options),s=await c.consume(l,(function(e){if(e)try{let n=e.content.toString(),t=JSON.parse(n);if(t.EndpointError){let e=new Error(t.EndpointError);r&&r(e,null),o(e)}else r&&r(null,t.EndpointResult),i(t.EndpointResult)}catch(e){r&&r(e,null),o(e)}finally{c.close()}}),{noAck:!0});let p={EndpointName:e,CommandParameters:n,ReplyID:a},u=`${t.ServiceName}/${e}`,d=await t.QueueClient.createChannel();s=await d.assertQueue(u,t.Options.command_queue_options),s=await d.sendToQueue(u,Buffer.from(JSON.stringify(p)),{contentType:"text/plain",persistent:!1}),await d.close()}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("amqplib")},function(e,n,t){"use strict";const r=t(0);var i=null;try{i=t(14)}catch(e){throw console.error("The npm library [tortoise] was not found."),console.error("To install [tortoise] please use: npm install --save tortoise"),e}n.TortoiseServiceProvider=function(e,n){let t=r.ServiceProvider(e,n);return t.QueueClient=null,t.DefaultOptions=()=>({server:"amqp://guest:guest@localhost:5672",connect_options:{connectRetries:30,connectRetryInterval:1e3},command_queue_options:{exclusive:!1,durable:!1,autoDelete:!0},reply_queue_options:{exclusive:!1,durable:!1,autoDelete:!0}}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.QueueClient=new i(t.Options.server,t.Options.connect_options),t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{let r=Object.keys(t.EndpointManager.Endpoints);for(let e=0;e<r.length;e++){let n=t.EndpointManager.Endpoints[r[e]];await n.Channel.close()}t.QueueClient&&(await t.QueueClient.destroy(),t.QueueClient=null),t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(r,i)=>{if(t.EndpointManager.EndpointExists(e))return void i(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));let o=await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}`,t.Options.command_queue_options).prefetch(1).subscribe((async function(n,r,i){try{let i=JSON.parse(n),o={ReplyID:i.ReplyID,EndpointResult:null,EndpointError:null};try{o.EndpointResult=await t.EndpointManager.HandleEndpoint(i.EndpointName,i.CommandParameters)}catch(e){o.EndpointError=e.message}o.ReplyID&&await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}/${o.ReplyID}`,t.Options.reply_queue_options).publish(JSON.stringify(o)),r()}catch(e){console.error(Error.message,e),i(!1)}}));t.EndpointManager.AddEndpoint(e,n).Channel=o,r(!0)}),t.CallEndpoint=async(e,n,r)=>new Promise(async(i,o)=>{if(!t.EndpointManager.EndpointExists(e))return void o(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`));let s=t.UniqueID(),a=await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}/${s}`,t.Options.reply_queue_options).prefetch(1).subscribe((async function(e,n,t){try{let t=JSON.parse(e);if(t.EndpointError){let e=new Error(t.EndpointError);r&&r(e,null),o(e)}else r&&r(null,t.EndpointResult),i(t.EndpointResult);n()}catch(e){t(!1),r&&r(e,null),o(e)}finally{await a.close()}})),l={EndpointName:e,CommandParameters:n,ReplyID:s};await t.QueueClient.queue(`/queue/${t.ServiceName}/${e}`,t.Options.command_queue_options).publish(l)}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("tortoise")},function(e,n,t){"use strict";const r=t(0);var i=null;try{i=t(16)}catch(e){throw console.error("The npm library [redis] was not found."),console.error("To install [redis] please use: npm install --save redis"),e}n.RedisServiceProvider=function(e,n){let t=r.ServiceProvider(e,n);return t.DefaultOptions=()=>({host:null,port:null,path:null,url:"redis://localhost:6379"}),t.OpenPort=async()=>new Promise(async(e,n)=>{t.IsPortOpen=!0,e(!0)}),t.ClosePort=async()=>new Promise(async(e,n)=>{let r=Object.keys(t.EndpointManager.Endpoints);for(let e=0;e<r.length;e++){let n=t.EndpointManager.Endpoints[r[e]];n.Channel.unsubscribe(),n.Channel.quit()}t.IsPortOpen=!1,e(!0)}),t.AddEndpoint=async(e,n)=>new Promise(async(r,o)=>{if(t.EndpointManager.EndpointExists(e))return void o(new Error(`The endpoint [${e}] already exists within [${t.ServiceName}].`));let s=`${t.ServiceName}/${e}`,a=i.createClient(t.Options);a.on("message",(async function(n,r){try{let n=JSON.parse(r),o={ReplyID:n.ReplyID,EndpointResult:null,EndpointError:null};try{o.EndpointResult=await t.EndpointManager.HandleEndpoint(n.EndpointName,n.CommandParameters)}catch(e){o.EndpointError=e.message}if(o.ReplyID){let n=`${t.ServiceName}/${e}/${o.ReplyID}`,r=i.createClient(t.Options);r.publish(n,JSON.stringify(o)),r.quit()}}catch(e){console.error(Error.message,e)}})),a.subscribe(s),t.EndpointManager.AddEndpoint(e,n).Channel=a,r(!0)}),t.CallEndpoint=async(e,n,r)=>new Promise(async(o,s)=>{if(!t.EndpointManager.EndpointExists(e))return void s(new Error(`The endpoint [${e}] does not exist within [${t.ServiceName}].`));let a=t.UniqueID(),l=`${t.ServiceName}/${e}/${a}`,c=i.createClient(t.Options);c.on("message",(function(e,n){try{let e=JSON.parse(n);if(e.EndpointError){let n=new Error(e.EndpointError);r&&r(n,null),s(n)}else r&&r(null,e.EndpointResult),o(e.EndpointResult)}catch(e){r&&r(e,null),s(e)}finally{c.unsubscribe(),c.quit()}})),c.subscribe(l);let p={EndpointName:e,CommandParameters:n,ReplyID:a},u=`${t.ServiceName}/${e}`,d=i.createClient(t.Options);d.publish(u,JSON.stringify(p)),d.quit()}),t.Options=t.ApplyDefaultOptions(n),t}},function(e,n){e.exports=require("redis")},function(e,n,t){"use strict";n.ServiceClient=function(){return{Services:{},ConnectService:function(e){let n=e.ServiceName;if(void 0!==this.Services[n])throw new Error(`The service [${n}] already exists.`);this.Services[n]=e},DisconnectService:function(e){void 0!==this.Services[e]&&delete this.Services[e]},CallEndpoint:function(e,n,t,r){if(void 0===this.Services[e])throw new Error(`The service [${e}] does not exist.`);this.Services[e].CallEndpoint(n,t,r)}}}}])}));